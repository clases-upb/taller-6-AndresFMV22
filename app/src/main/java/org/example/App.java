/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example;
import java.util.Random;
import java.util.Scanner;

public class App {

    public static void main(String[] args) {
        try {

        System.out.println(menu());
        System.out.println(temperaturas());
        System.out.println(manipular_vector());
        System.out.println(convertir_decimal(32));
        System.out.println(mostrar_transpuesta());
        System.out.println(calcular_producto_division());
        System.out.println(llenar_matriz());
        System.out.println(calcular_cantidad());

        } catch (Exception e) {
             System.out.println("Ocurrio un error" + e);
        }
    }

    /*
     * 1. Implemente un programa en java donde inserte elementos en dos vectores
     * globales de tamaños aleatorios y de contenido aleatorio (uno numérico y otro
     * de Strings). Considere dejar espacios libres en los vectores.
     * 
     * Desde un menú en el programa principal debe considerar cada opción para
     * llamar las siguientes funciones que también debe programar:
     * 
     * a. Recorrer secuencialmente (recibe un true cuando va del primero al último y
     * un false cuando va del último al primero)
     * • De primer elemento a último elemento: Imprime desde el primer elemento
     * hasta el último del vector dado en el parámetro de entrada.
     * • De último elemento al primer elemento: Imprime desde el último elemento
     * hasta el primero del vector dado en el parámetro de entrada.
     * 
     * b. Actualizar: recibe la posición que va a actualizar y el elemento. Al final
     * imprime el vector actualizado.
     * 
     * c. Añadir: después del último: recibe el elemento que va a añadir. Al final
     * imprime el vector actualizado.
     * 
     * d. Borrar: Recibe la posición donde del elemento que va a borrar.
     * 
     * e. Ordenar el vector:
     * • Ascendentemente.
     * • Descendentemente.
     * 
     * f. Búsqueda: Recibe como parámetro el elemento a buscar y devuelve un String
     * separado por el carácter '-', mostrando las posiciones donde se encuentra el
     * elemento.
     */
    
     public static String menu() throws Exception {

        try {

            Scanner teclado = new Scanner(System.in);
            Random random = new Random();

            int numerico = random.nextInt(10) + 1;
            int strings = random.nextInt(10) + 1;

            int[] v_numerico = new int[numerico];
            String[] v_strings = new String[strings];

            for (int N = 0; N < numerico; N++) {
                v_numerico[N] = random.nextInt(100);
            }
            for (int N = 0; N < strings; N++) {
                v_strings[N] = "String" + (N + 1);
            }

            String resultado = "";
            boolean continuar = true;

            while (continuar) {

                System.out.println("Menú:");
                System.out.println("1. Recorrer vector numérico");
                System.out.println("2. Actualizar elemento en vector numérico");
                System.out.println("3. Añadir elemento a vector numérico");
                System.out.println("4. Borrar elemento de vector numérico");
                System.out.println("5. Ordenar vector numérico");
                System.out.println("6. Buscar elemento en vector numérico");
                System.out.println("7. Salir");

                int opcion = teclado.nextInt();
                switch (opcion) {
                    case 1:
                        resultado = recorrer_v_numerico(v_numerico, true) + "\n";
                        break;
                    case 2:
                        resultado = actualizar_numerico(v_numerico, teclado) + "\n";
                        break;
                    case 3:
                        resultado = añadir_numerico(v_numerico, teclado) + "\n";
                        break;
                    case 4:
                        resultado = borrar_numerico(v_numerico, teclado) + "\n";
                        break;
                    case 5:
                        resultado = ordenar_numerico(v_numerico, teclado) + "\n";
                        break;
                    case 6:
                        resultado = buscar_numerico(v_numerico, teclado) + "\n";
                        break;
                    case 7:
                        continuar = false;
                        break;
                    default:
                        resultado = "Opción no válida.\n";
                }

                System.out.println(resultado);
            }

            teclado.close();
            return "Termino el menu";

        } catch (Exception e) {
            throw new Exception("Ocurrió un error: " + e);
        }
    }

    public static String recorrer_v_numerico(int[] vector, boolean Primero_a_ultimo) throws Exception {
        try {
            String resultado = "";

            if (Primero_a_ultimo) {
                for (int N = 0; N < vector.length; N++) {
                    if (N == vector.length - 1) {
                        resultado += vector[N];
                    } else {
                        resultado += vector[N] + " ";
                    }
                }
            } else {
                for (int N = vector.length - 1; N >= 0; N--) {
                    if (N == 0) {
                        resultado += vector[N];
                    } else {
                        resultado += vector[N] + " ";
                    }
                }
            }

            return "Vector numérico: " + resultado;

        } catch (Exception e) {
            throw new Exception("Error al recorrer el vector numérico: " + e);
        }
    }

    public static String actualizar_numerico(int[] vector, Scanner teclado) throws Exception {
        try {
            System.out.print("Ingrese la posición a actualizar (0 a " + (vector.length - 1) + "): ");
            int posicion = teclado.nextInt();

            if (posicion < 0 || posicion >= vector.length) {
                throw new Exception("Posición inválida.");
            }

            System.out.print("Ingrese el nuevo valor: ");
            int nuevo_valor = teclado.nextInt();

            vector[posicion] = nuevo_valor;

            return "Vector actualizado: " + recorrer_v_numerico(vector, true);

        } catch (Exception e) {
            throw new Exception("Error al actualizar el elemento: " + e);
        }
    }

    public static String añadir_numerico(int[] vector, Scanner teclado) throws Exception {
        try {
            System.out.print("Ingrese el nuevo elemento: ");
            int nuevo_elemento = teclado.nextInt();

            int[] nuevo_vector = new int[vector.length + 1];

           
            for (int i = 0; i < vector.length; i++) {
                nuevo_vector[i] = vector[i];
            }

           
            nuevo_vector[nuevo_vector.length - 1] = nuevo_elemento;

            return "Vector actualizado: " + recorrer_v_numerico(nuevo_vector, true);

        } catch (Exception e) {
            throw new Exception("Error al añadir el elemento: " + e); 
        }
    }

    public static String borrar_numerico(int[] vector, Scanner teclado) throws Exception {
        try {
            System.out.print("Ingrese la posición a borrar (0 a " + (vector.length - 1) + "): ");
            int posicion = teclado.nextInt();

            if (posicion < 0 || posicion >= vector.length) {
                throw new Exception("Posición inválida" + e);
            }

            
            int[] nuevo_vector = new int[vector.length - 1];
            for (int N = 0, j = 0; N < vector.length; N++) {
                if (N != posicion) {
                    nuevo_vector[j++] = vector[N];
                }
            }

            return "Vector actualizado: " + recorrer_v_numerico(nuevo_vector, true); 
        } catch (Exception e) {
            throw new Exception("Error al borrar el elemento: " + e); 
        }
    }

    public static String ordenar_numerico(int[] vector, Scanner teclado) throws Exception {
        try {
            System.out.println("1. Ordenar ascendentemente");
            System.out.println("2. Ordenar descendentemente");
            int opcion = teclado.nextInt();
    
            int[] vector_ordenado = new int[vector.length];
    
            for (int i = 0; i < vector.length; i++) {
                vector_ordenado[i] = vector[i];
            }

            int temp = vector_ordenado[j];
            for (int i = 0; i < vector_ordenado.length - 1; i++) {
                for (int j = 0; j < vector_ordenado.length - 1 - i; j++) {
                    if (opcion == 1) {
                        
                        if (vector_ordenado[j] > vector_ordenado[j + 1]) {   
                            vector_ordenado[j] = vector_ordenado[j + 1];
                            vector_ordenado[j + 1] = temp;
                        }
                    } else if (opcion == 2) {
             
                        if (vector_ordenado[j] < vector_ordenado[j + 1]) {
                            vector_ordenado[j] = vector_ordenado[j + 1];
                            vector_ordenado[j + 1] = temp;
                        }
                    } else {
                        throw new Exception("Opción no válida.");
                    }
                }
            }
    
            return "Vector ordenado: " + recorrer_v_numerico(vector_ordenado, true); 
    
        } catch (Exception e) {
            throw new Exception("Error al ordenar el vector: " + e); 
        }
    }
    

    public static String buscar_numerico(int[] vector, Scanner teclado) throws Exception {
        try {
            System.out.print("Ingrese el elemento a buscar: ");
            int elemento_buscar = teclado.nextInt();
    
            String posiciones = "";
            for (int N = 0; N < vector.length; N++) {
                if (vector[N] == elemento_buscar) {
                    posiciones += N + " - "; 
                }
            }
    
            if (!posiciones.equals("")) { 
                return "Elementos encontrados en las posiciones: " + posiciones;
            } else {
                return "Elemento no encontrado en el vector.";
            }
        } catch (Exception e) {
            throw new Exception("Error al buscar el elemento: " );
        }
    }

    /*
     * 2. Escriba un algoritmo que calcule aleatoriamente N temperaturas, las lleve
     * a un vector y luego calcule su media, cuántas temperaturas están por encima
     * de la media y cuántas por debajo.
     */
    
    public static Double[] temperaturas() throws Exception {

        try {
            Scanner teclado = new Scanner(System.in);
            System.out.println("Ingrese el número de temperaturas: ");
            int fila = teclado.nextInt();

            if (fila <= 0) {
                System.out.println("El número de temperaturas debe ser mayor a 0");

            }

            teclado.close();

            Double[] temperatura = new Double[fila];
            String[] resultado = new String[3];

            for (int cantidad = 0; cantidad < temperatura.length; cantidad++) {
                temperatura[cantidad] = -20 + (Math.random() * 50);
                System.out.println("Temperatura " + (cantidad + 1) + ": " + temperatura[cantidad] + " °C");
            }

            Double suma = 0.0;
            for (int cantidad = 0; cantidad < temperatura.length; cantidad++) {
                suma += temperatura[cantidad];
            }

            Double media = suma / temperatura.length;
            System.out.println("La media de las temperaturas fue de: " + media + "°C");
            resultado[0] = "La media de las temperaturas fue de: " + media + "°C";

            int por_Encima = 0;
            int por_Debajo = 0;

            for (int cantidad = 0; cantidad < temperatura.length; cantidad++) {
                if (temperatura[cantidad] > media) {
                    por_Encima++;
                } else if (temperatura[cantidad] < media) {
                    por_Debajo++;
                }
            }

            System.out.println("Las temperaturas por debacolumnao de la media fueron: " + por_Debajo);
            System.out.println("Las temperaturas por encima de la media fueron: " + por_Encima);

            resultado[1] = "Temperaturas por encima de la media: " + por_Encima;
            resultado[2] = "Temperaturas por debacolumnao de la media: " + por_Debajo;

            return temperatura;

        } catch (Exception e) {
            throw new Exception("Ocurrió un error: " + e);
        }
    }

    
    /*
     * 3. Cargue un vector a partir de un archivo de palabras, con mínimo 10
     * palabras. Ordene el vector de manera ascendente y luego de forma descendente.
     * 
     * Escriba el vector inicial sin ordenar, los vectores ordenados.
     */

    /*
     * 4. Escriba un algoritmo que cree un vector de N elementos (el N es dado por
     * el usuario) de números short aleatorios positivos mayores que cero, y luego
     * le pregunte al usuario qué posición quiere eliminar. Luego por un menú
     * presente las opciones: Dejar la casilla en 0 o desplazar los elementos de
     * manera que el cero quede en la última posición del vector. Después de la
     * operación mostrará el vector cómo va quedando y volverá a preguntar qué
     * posición quiere borrar y mostrará nuevamente el menú. En el menú aparecerá la
     * opción para terminar el programa.
     */
    
     public static String manipular_vector() throws Exception {
        try {
            Scanner teclado = new Scanner(System.in);
            Random random = new Random();
            String resultado = "";

            System.out.print("Ingrese el tamaño del vector: ");
            int numero = teclado.nextInt();

            if (numero <= 0) {
                System.out.print("El tamaño del vector debe ser mayor a cero.");
            }

            short[] vector = new short[numero];

            for (int pos = 0; pos < numero; pos++) {
                vector[pos] = (short) (random.nextInt(100) + 1);
            }

            boolean terminar = false;
            while (!terminar) {
                resultado += mostrar_vector(vector);

                System.out.print("Ingrese la posición que desea eliminar (o -1 para salir): ");
                int posicion = teclado.nextInt();

                if (posicion == -1) {
                    terminar = true;
                } else if (posicion < 0 || posicion >= numero) {
                    System.out.println("Posición inválida, intenta otra vez.");
                } else {
                    System.out.println("1. Poner en 0 la casilla.");
                    System.out.println("2. Desplazar y poner el 0 al final del vector.");
                    System.out.print("Elija una opción: ");
                    int opcion = teclado.nextInt();

                    if (opcion == 1) {
                        vector = cero_posicion(vector, posicion);
                    } else if (opcion == 2) {
                        vector = desplazar_cero(vector, posicion);
                    } else {
                        System.out.println("Opción no válida.");
                    }
                }
            }
            teclado.close();
            return resultado;

        } catch (Exception e) {
            throw new Exception("Ocurrio un error " + e);
        }

    }

    public static String mostrar_vector(short[] vector) throws Exception {
        try {
            String vector_str = "Vector actual: ";
            for (int N = 0; N < vector.length; N++) {
                vector_str += vector[N] + " ";
            }
            vector_str += "\n";
            return vector_str;
        } catch (Exception e) {
            throw new Exception("Ocurrió un error " + e);
        }
    }

    public static short[] cero_posicion(short[] vector, int posicion) throws Exception {
        try {
            vector[posicion] = 0;
            return vector;
        } catch (Exception e) {
            throw new Exception("Ocurrió un error " + e);
        }
    }

    public static short[] desplazar_cero(short[] vector, int posicion) throws Exception {
        try {
            short temp = vector[posicion];
            for (int pos = posicion; pos < vector.length - 1; pos++) {
                vector[pos] = vector[pos + 1];
            }
            vector[vector.length - 1] = temp;
            return vector;
        } catch (Exception e) {
            throw new Exception("Ocurrió un error " + e);
        }
    }

    /*
     * 5. Escriba un algoritmo para convertir un número decimal en un número
     * hexadecimal, apoyado en vectores.
     */
    
    public static String convertir_decimal(int decimal) throws Exception {
        try {
            char[] hexa = new char[20];
            int indice = 0;

            while (decimal > 0) {
                int convertir = decimal % 16;
                if (convertir < 10) {
                    hexa[indice] = (char) (convertir + '0');
                } else {
                    hexa[indice] = (char) (convertir - 10 + 'A');
                }
                decimal /= 16;
                indice++;
            }

            String resultado = "Tu numero Decimal en Hexadecimal es: ";
            for (int fila = indice - 1; fila >= 0; fila--) {
                resultado += hexa[fila];
            }

            return resultado;

        } catch (Exception e) {
            throw new Exception("Ocurrió un error: " + e);
        }
    }


    /*
     * 6. Escriba un algoritmo que solicite al usuario el orden de una matriz
     * cuadrática, implemente su matriz transpuesta (investiga qué es) y la imprima.
     */
    
    public static String mostrar_transpuesta() throws Exception {
        try {
            int n = solicitar_orden_matriz();
            int[][] matriz = crear_matriz(n);

            String resultado = "Matriz Original:\n";
            resultado += imprimir_matriz(matriz);

            int[][] transpuesta = obtener_transpuesta(matriz);
            resultado += "Matriz Transpuesta:\n";
            resultado += imprimir_matriz(transpuesta);

            return resultado;
        } catch (Exception e) {
            throw new Exception("Ocurrió un error al mostrar la transpuesta: " + e);
        }
    }

    public static int solicitar_orden_matriz() throws Exception {
        try {
            Scanner teclado = new Scanner(System.in);
            System.out.print("Ingrese el orden de la matriz cuadrática: ");
            int n = teclado.nextInt();
            if (n <= 0) {
                System.out.println("El orden de la matriz debe ser un número entero positivo." + e);
            }
            teclado.close();
            return n;
        } catch (Exception e) {
            throw new Exception("Ocurrió un error al solicitar el orden de la matriz: " + e);
        }
    }

    public static int[][] crear_matriz(int n) throws Exception {
        try {
            int[][] matriz = new int[n][n];
            for (int fila = 0; fila < n; fila++) {
                for (int columna = 0; columna < n; columna++) {
                    matriz[fila][columna] = (int) (Math.random() * 10);
                }
            }
            return matriz;
        } catch (Exception e) {
            throw new Exception("Ocurrió un error al crear la matriz: " + e);
        }
    }

    public static int[][] obtener_transpuesta(int[][] matriz) throws Exception {
        try {
            if (matriz == null || matriz.length == 0) {
                throw new Exception("La matriz no puede ser nula o vacía.");
            }

            int n = matriz.length;
            int[][] transpuesta = new int[n][n];

            for (int fila = 0; fila < n; fila++) {
                for (int columna = 0; columna < n; columna++) {
                    transpuesta[columna][fila] = matriz[fila][columna];
                }
            }

            return transpuesta;
        } catch (Exception e) {
            throw new Exception("Ocurrió un error al obtener la transpuesta: " + e);
        }
    }

    public static String imprimir_matriz(int[][] matriz) throws Exception {
        try {
            String resultado = "";
            for (int fila = 0; fila < matriz.length; fila++) {
                for (int columna = 0; columna < matriz[fila].length; columna++) {
                    resultado += matriz[fila][columna] + " ";
                }
                resultado += "\n";
            }
            return resultado;
        } catch (Exception e) {
            throw new Exception("Ocurrió un error al imprimir la matriz: " + e);
        }
    }


    /*
     * 7. Escriba un algoritmo que calcule el producto y la división. Los operandos
     * serán la suma de elementos de la diagonal principal y la suma de los
     * elementos de la diagonal secundaria. Los elementos de la matriz deben ser
     * llenados usando la función random para calcular números aleatorios entre 10 y
     * 100.
     */
     public static String calcular_producto_division() throws Exception {

        try {
            String resultado = "";
            int tamaño = 5;
            int[][] matriz = new int[tamaño][tamaño];
            Random random = new Random();

            int suma_diagonal_principal = 0;
            int suma_diagonal_secundaria = 0;

            for (int fila = 0; fila < tamaño; fila++) {
                for (int columna = 0; columna < tamaño; columna++) {
                    matriz[fila][columna] = random.nextInt(91) + 10;

                    if (fila == columna) {
                        suma_diagonal_principal += matriz[fila][columna];
                    }

                    if (fila + columna == tamaño - 1) {
                        suma_diagonal_secundaria += matriz[fila][columna];
                    }
                }
            }

            int producto = suma_diagonal_principal * suma_diagonal_secundaria;
            double division;
            if (suma_diagonal_secundaria != 0) {
                division = (double) suma_diagonal_principal / suma_diagonal_secundaria;
            } else {
                division = 0;
            }

            resultado += "Matriz generada:\n";
            for (int fila = 0; fila < tamaño; fila++) {
                for (int columna = 0; columna < tamaño; columna++) {
                    resultado += matriz[fila][columna] + "\t";
                }
                resultado += "\n";
            }

            resultado += "Suma de la diagonal principal: " + suma_diagonal_principal + "\n";
            resultado += "Suma de la diagonal secundaria: " + suma_diagonal_secundaria + "\n";
            resultado += "Producto de las sumas: " + producto + "\n";
            resultado += "División de las sumas: " + division + "\n";

            return resultado;

        } catch (Exception e) {
            throw new Exception("Ocurrió un error: " + e.getMessage());
        }
    }


    /*
     * 8. Escriba un algoritmo que llene de manera aleatoria una matriz de 100 filas
     * por 3 columnas con Xs y Os. Y mediante un vector cuente el número de Xs y Os
     * en cada fila. Imprima la matriz antes de llenarla, luego de llenarla y el
     * vector con el resultado.
     */
    
    public static String llenar_matriz() throws Exception {

        try {
            String[][] matriz = new String[100][3];
            int[][] contador_xs_os = new int[100][2];

            String resultado = "Matriz antes de llenarla: \n";

            for (int fila = 0; fila < 100; fila++) {
                for (int columna = 0; columna < 3; columna++) {
                    resultado += "- ";
                }
                resultado += "\n";
            }

            for (int fila = 0; fila < 100; fila++) {
                for (int columna = 0; columna < 3; columna++) {
                    if (Math.random() < 0.5) {
                        matriz[fila][columna] = "Xs";

                    } else {
                        matriz[fila][columna] = "Os";
                    }

                    if (matriz[fila][columna] == "Xs") {
                        contador_xs_os[fila][0]++;
                    } else {
                        contador_xs_os[fila][1]++;
                    }
                }
            }

            resultado += "Matriz después de llenarla:\n";

            for (int fila = 0; fila < 100; fila++) {
                for (int columna = 0; columna < 3; columna++) {
                    resultado += matriz[fila][columna] + " ";
                }
                resultado += "\n";
            }

            resultado += "Conteo de Xs y Os por fila:\n";
            for (int fila = 0; fila < 100; fila++) {
                resultado += "Fila " + fila + ": Xs = " + contador_xs_os[fila][0] + ", Os = " +
                        contador_xs_os[fila][1] + "\n";
            }

            return resultado;

        } catch (Exception e) {
            throw new Exception("Ocurrió un error: " + e);
        }
    }


    /*
     * 9. Llene una matriz de 5x5 con números aleatorios entre 1 y 9. En un vector
     * adicional, calcule la cantidad de números repetidos por cada fila y en otro
     * vector la cantidad de números repetidos de cada columna.
     */
    
     public static String calcular_cantidad() throws Exception {

        try {
            int[][] aleatorios = new int[5][5];
            int[] repetidos_fila = new int[5];
            int[] repetidos_columna = new int[5];
            int[] contador = new int[10];

            int fila, columna, num;
            for (fila = 0; fila < 5; fila++) {
                for (columna = 0; columna < 5; columna++) {
                    aleatorios[fila][columna] = (int) (1 + Math.random() * 9);
                }
            }

            for (fila = 0; fila < 5; fila++) {

                for (num = 0; num < 10; num++) {
                    contador[num] = 0;
                }

                for (columna = 0; columna < 5; columna++) {
                    contador[aleatorios[fila][columna]]++;
                }

                for (num = 1; num <= 9; num++) {
                    if (contador[num] > 1) {
                        repetidos_fila[fila] += contador[num] - 1;
                    }
                }
            }

            for (columna = 0; columna < 5; columna++) {

                for (num = 0; num < 10; num++) {
                    contador[num] = 0;
                }

                for (fila = 0; fila < 5; fila++) {
                    contador[aleatorios[fila][columna]]++;
                }

                for (num = 1; num <= 9; num++) {
                    if (contador[num] > 1) {
                        repetidos_columna[columna] += contador[num] - 1;
                    }
                }
            }

            String resultado = "";

            resultado += "Matriz generada:\n";
            for (fila = 0; fila < 5; fila++) {
                for (columna = 0; columna < 5; columna++) {
                    resultado += aleatorios[fila][columna] + " ";
                }
                resultado += "\n";
            }

            resultado += "Repetidos por fila:\n";
            for (fila = 0; fila < 5; fila++) {
                resultado += "Fila " + fila + ": " + repetidos_fila[fila] + "\n";
            }

            resultado += "Repetidos por columna:\n";
            for (columna = 0; columna < 5; columna++) {
                resultado += "Columna " + columna + ": " + repetidos_columna[columna] + "\n";
            }

            return resultado;

        } catch (Exception e) {
            throw new Exception("Ocurrió un error: " + e);
        }
    }

}
